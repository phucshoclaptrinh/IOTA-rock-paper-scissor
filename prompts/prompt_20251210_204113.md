**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `testnet`
- **Package ID:** `0x019f66584bfda8c80ebf6ddd685a06e4cec9dd77e20f64c00eb5417bf20635c8`
- **Module Name:** `game`
- **Available Methods:**

  * `play` (constant: `PLAY`)

---

# **Move Contract: `contract/rock_paper_scissor/sources/rock_paper_scissor.move`**

```move
module rock_paper_scissor::game {
use std::bcs;
const ROCK: u8 = 0;
const PAPER: u8 = 1;
const SCISSORS: u8 = 2;
const RESULT_TIE: u8 = 0;
const RESULT_PLAYER_WIN: u8 = 1;
const RESULT_MACHINE_WIN: u8 = 2;
const E_INVALID_MOVE: u64 = 0;
public struct Match has key, store {
id: UID,
player: address,
player_move: u8,
machine_move: u8,
result: u8,
}
fun validate_move(choice: u8) {
assert!(choice < 3, E_INVALID_MOVE);
}
fun compute_result(player_move: u8, machine_move: u8): u8 {
if (player_move == machine_move) {
RESULT_TIE
} else if (
(player_move == ROCK && machine_move == SCISSORS) ||
(player_move == PAPER && machine_move == ROCK) ||
(player_move == SCISSORS && machine_move == PAPER)
) {
RESULT_PLAYER_WIN
} else {
RESULT_MACHINE_WIN
}
}
fun machine_choice(id: &UID): u8 {
let seed_bytes = bcs::to_bytes(&object::uid_to_address(id));
let first = *vector::borrow(&seed_bytes, 0);
first % 3
}
#[allow(lint(self_transfer))]
public fun play(player_move: u8, ctx: &mut tx_context::TxContext) {
validate_move(player_move);
let sender = tx_context::sender(ctx);
let uid = object::new(ctx);
let machine_move = machine_choice(&uid);
let result = compute_result(player_move, machine_move);
transfer::public_transfer(
Match {
id: uid,
player: sender,
player_move,
machine_move,
result,
},
sender,
);
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
"use client"

import { useEffect, useState } from "react"
import {
  useCurrentAccount,
  useIotaClient,
  useIotaClientQuery,
  useSignAndExecuteTransaction,
} from "@iota/dapp-kit"
import type { IotaObjectData } from "@iota/iota-sdk/client"
import { Transaction } from "@iota/iota-sdk/transactions"
import { useNetworkVariable } from "@/lib/config"

// ============================================================================
// CONTRACT CONFIGURATION
// ============================================================================

export const CONTRACT_MODULE = "game"
export const CONTRACT_METHODS = {
  PLAY: "play",
} as const

// ============================================================================
// DATA EXTRACTION
// ============================================================================

function getObjectFields(data: IotaObjectData): {
  owner: string
  player: string
  playerMove: number
  machineMove: number
  result: number
} | null {
  if (data.content?.dataType !== "moveObject") {
    console.log("Data is not a moveObject:", data.content?.dataType)
    return null
  }

  type MatchFields = {
    player?: string
    player_move?: number | string
    machine_move?: number | string
    result?: number | string
  }

  const rawFields = data.content.fields as unknown
  if (!rawFields || typeof rawFields !== "object") {
    console.log("No fields found in object data")
    return null
  }
  const fields = rawFields as MatchFields

  const owner = data.owner && typeof data.owner === "object" && "AddressOwner" in data.owner
    ? String(data.owner.AddressOwner)
    : ""

  return {
    owner,
    player: String(fields.player || ""),
    playerMove: Number(fields.player_move),
    machineMove: Number(fields.machine_move),
    result: Number(fields.result),
  }
}

// ============================================================================
// MAIN HOOK
// ============================================================================

export interface ContractData {
  owner: string
  player: string
  playerMove: number
  machineMove: number
  result: number
}

export interface ContractState {
  isLoading: boolean
  isFetching: boolean
  isPending: boolean
  isConfirming: boolean
  isConfirmed: boolean
  hash: string | undefined
  error: Error | null
}

export interface ContractActions {
  play: (playerMove: number) => Promise<void>
  loadMatch: (matchId: string) => void
  clearObject: () => void
}

export const useContract = () => {
  const currentAccount = useCurrentAccount()
  const address = currentAccount?.address
  const packageId = useNetworkVariable("packageId")
  const iotaClient = useIotaClient()
  const { mutate: signAndExecute, isPending } = useSignAndExecuteTransaction()
  const [objectId, setObjectId] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hash, setHash] = useState<string | undefined>()
  const [transactionError, setTransactionError] = useState<Error | null>(null)

  useEffect(() => {
    if (typeof window !== "undefined") {
      const hash = window.location.hash.slice(1)
      if (hash) setObjectId(hash)
    }
  }, [])

  const { data, isPending: isFetching, error: queryError, refetch } = useIotaClientQuery(
    "getObject",
    {
      id: objectId!,
      options: { showContent: true, showOwner: true },
    },
    {
      enabled: !!objectId,
    }
  )

  const fields = data?.data ? getObjectFields(data.data) : null
  const isOwner = fields?.owner?.toLowerCase() === address?.toLowerCase()
  const objectExists = !!data?.data
  const hasValidData = !!fields

  const play = async (playerMove: number) => {
    if (!packageId) {
      setTransactionError(new Error("Package ID not configured for the selected network."))
      return
    }

    if (playerMove < 0 || playerMove > 2) {
      setTransactionError(new Error("Move must be 0 (rock), 1 (paper), or 2 (scissors)."))
      return
    }

    try {
      setIsLoading(true)
      setTransactionError(null)
      setHash(undefined)

      const tx = new Transaction()
      tx.moveCall({
        arguments: [tx.pure.u8(playerMove)],
        target: `${packageId}::${CONTRACT_MODULE}::${CONTRACT_METHODS.PLAY}`,
      })

      signAndExecute(
        { transaction: tx },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            try {
              const { effects } = await iotaClient.waitForTransaction({
                digest,
                options: { showEffects: true },
              })
              const newObjectId = effects?.created?.[0]?.reference?.objectId
              if (newObjectId) {
                setObjectId(newObjectId)
                if (typeof window !== "undefined") {
                  window.location.hash = newObjectId
                }
              } else {
                console.warn("No object ID found in transaction effects")
              }
              await refetch()
            } catch (waitError) {
              console.error("Error waiting for transaction:", waitError)
            } finally {
              setIsLoading(false)
            }
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("Error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("Error playing match:", err)
      setIsLoading(false)
    }
  }

  const loadMatch = (matchId: string) => {
    if (!matchId) return
    setObjectId(matchId)
    setTransactionError(null)
    if (typeof window !== "undefined") {
      window.location.hash = matchId
    }
  }

  const contractData: ContractData | null = fields
    ? {
        owner: fields.owner,
        player: fields.player,
        playerMove: fields.playerMove,
        machineMove: fields.machineMove,
        result: fields.result,
      }
    : null

  const clearObject = () => {
    setObjectId(null)
    setTransactionError(null)
    if (typeof window !== "undefined") {
      window.location.hash = ""
    }
  }

  const actions: ContractActions = {
    play,
    loadMatch,
    clearObject,
  }

  const contractState: ContractState = {
    isLoading: isLoading || isPending,
    isFetching,
    isPending,
    isConfirming: false,
    isConfirmed: !!hash && !isLoading && !isPending,
    hash,
    error: queryError || transactionError,
  }

  return {
    data: contractData,
    actions,
    state: contractState,
    objectId,
    isOwner,
    objectExists,
    hasValidData,
    packageId,
  }
}

```

---

# File 2: `components/sample.tsx`

```tsx
"use client"

import { useCurrentAccount } from "@iota/dapp-kit"
import { useContract } from "@/hooks/useContract"
import { Button, Container, Flex, Heading, Separator, Text, TextField } from "@radix-ui/themes"
import ClipLoader from "react-spinners/ClipLoader"
import { useMemo, useState } from "react"

const moves = [
  { label: "Rock", value: 0 },
  { label: "Paper", value: 1 },
  { label: "Scissors", value: 2 },
]

const moveName = (value?: number) => {
  const found = moves.find((m) => m.value === value)
  return found ? found.label : "Unknown"
}

const resultLabel = (result?: number) => {
  if (result === 0) return "Draw"
  if (result === 1) return "You won"
  if (result === 2) return "Machine won"
  return "Not played yet"
}

const SampleIntegration = () => {
  const currentAccount = useCurrentAccount()
  const { data, actions, state, objectId, objectExists, hasValidData, packageId } = useContract()
  const [matchIdInput, setMatchIdInput] = useState("")

  const isConnected = !!currentAccount
  const disabled = state.isPending || state.isLoading

  const statusText = useMemo(() => {
    if (state.isPending || state.isLoading) return "Submitting move..."
    if (state.isConfirmed) return "Transaction confirmed"
    if (state.error) return "Something went wrong"
    return "Ready to play"
  }, [state.isPending, state.isLoading, state.isConfirmed, state.error])

  if (!isConnected) {
    return (
      <div style={{ minHeight: "100vh", display: "flex", alignItems: "center", justifyContent: "center", padding: "1rem" }}>
        <div style={{ maxWidth: "520px", width: "100%", background: "var(--gray-a2)", padding: "1.5rem", borderRadius: "16px", border: "1px solid var(--gray-a5)" }}>
          <Heading size="6" style={{ marginBottom: "0.75rem" }}>Rock 路 Paper 路 Scissors</Heading>
          <Text size="2" style={{ color: "var(--gray-a11)" }}>
            Connect your wallet to challenge the on-chain machine. Each play mints a match object that stores both moves and the outcome.
          </Text>
        </div>
      </div>
    )
  }

  return (
    <div style={{ minHeight: "100vh", padding: "1rem", background: "linear-gradient(135deg, #0f172a 0%, #0b1221 100%)" }}>
      <Container style={{ maxWidth: "920px", margin: "0 auto" }}>
        <div style={{ background: "rgba(255,255,255,0.03)", border: "1px solid rgba(255,255,255,0.08)", borderRadius: "16px", padding: "1.5rem", marginBottom: "1rem" }}>
          <Flex justify="between" align="center" gap="3" wrap="wrap">
            <div>
              <Heading size="7" style={{ marginBottom: "0.35rem" }}>Rock 路 Paper 路 Scissors</Heading>
              <Text size="2" style={{ color: "var(--gray-a11)" }}>
                Play against a pseudo-random on-chain machine. Results are stored as Move objects on testnet.
              </Text>
            </div>
            <div style={{ textAlign: "right" }}>
              <Text size="1" style={{ color: "var(--gray-a9)", display: "block" }}>Package ID</Text>
              <Text style={{ fontFamily: "monospace", color: "#ffffff", wordBreak: "break-all" }}>
                {packageId || "Not deployed"}
              </Text>
            </div>
          </Flex>
        </div>

        <div style={{ display: "grid", gap: "1rem" }}>
          <div style={{ background: "rgba(255,255,255,0.03)", border: "1px solid rgba(255,255,255,0.08)", borderRadius: "16px", padding: "1.25rem" }}>
            <Flex justify="between" align="center" wrap="wrap" gap="3" style={{ marginBottom: "0.75rem" }}>
              <div>
                <Heading size="5" style={{ marginBottom: "0.35rem" }}>Choose your move</Heading>
                <Text size="2" style={{ color: "var(--gray-a11)" }}>Machine move is derived from the minted object ID.</Text>
              </div>
              <Text size="2" style={{ color: "var(--gray-a10)" }}>{statusText}</Text>
            </Flex>
            <Separator style={{ marginBottom: "0.75rem", background: "var(--gray-a6)" }} />
            <Flex gap="3" wrap="wrap">
              {moves.map((move) => (
                <Button
                  key={move.value}
                  size="3"
                  variant="soft"
                  disabled={disabled || !packageId}
                  onClick={() => actions.play(move.value)}
                >
                  {disabled && state.isPending ? <ClipLoader size={14} style={{ marginRight: "8px" }} /> : null}
                  {move.label}
                </Button>
              ))}
            </Flex>
            {!packageId && (
              <Text size="2" style={{ color: "var(--red-10)", marginTop: "0.75rem", display: "block" }}>
                Package ID missing. Deploy the Move package to testnet to enable play.
              </Text>
            )}
          </div>

          <div style={{ background: "rgba(255,255,255,0.03)", border: "1px solid rgba(255,255,255,0.08)", borderRadius: "16px", padding: "1.25rem" }}>
            <Flex justify="between" align="center" wrap="wrap" gap="3" style={{ marginBottom: "0.75rem" }}>
              <div>
                <Heading size="5" style={{ marginBottom: "0.35rem" }}>Latest match</Heading>
                <Text size="2" style={{ color: "var(--gray-a11)" }}>Matches are stored as Move objects. Paste an object ID to inspect.</Text>
              </div>
              <Flex gap="2" align="center">
                <TextField.Root
                  value={matchIdInput || objectId || ""}
                  onChange={(e) => setMatchIdInput(e.target.value)}
                  placeholder="Paste match object ID"
                  style={{ minWidth: "260px" }}
                />
                <Button
                  variant="soft"
                  disabled={!(matchIdInput || objectId)}
                  onClick={() => actions.loadMatch(matchIdInput || objectId || "")}
                >
                  Load
                </Button>
                <Button
                  variant="ghost"
                  color="gray"
                  onClick={() => {
                    setMatchIdInput("")
                    actions.clearObject()
                  }}
                >
                  Clear
                </Button>
              </Flex>
            </Flex>

            <Separator style={{ marginBottom: "0.75rem", background: "var(--gray-a6)" }} />

            {state.isFetching && !data ? (
              <Text>Fetching match...</Text>
            ) : state.error ? (
              <div style={{ padding: "1rem", background: "var(--red-a3)", borderRadius: "12px" }}>
                <Text style={{ color: "var(--red-11)" }}>
                  {(state.error as Error)?.message || "Unable to read match object."}
                </Text>
              </div>
            ) : objectExists && !hasValidData ? (
              <div style={{ padding: "1rem", background: "var(--yellow-a3)", borderRadius: "12px" }}>
                <Text style={{ color: "var(--yellow-11)" }}>
                  Object found, but its data layout does not match the expected Match struct.
                </Text>
              </div>
            ) : data ? (
              <div style={{ display: "grid", gap: "0.65rem" }}>
                <div style={{ padding: "0.75rem", borderRadius: "10px", background: "var(--gray-a3)" }}>
                  <Text size="2" style={{ display: "block", color: "var(--gray-12)" }}>Outcome</Text>
                  <Text size="4" style={{ color: data.result === 1 ? "var(--green-10)" : data.result === 2 ? "var(--red-10)" : "var(--amber-10)" }}>
                    {resultLabel(data.result)}
                  </Text>
                </div>
                <div style={{ display: "grid", gap: "0.35rem", gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))" }}>
                  <div style={{ padding: "0.75rem", background: "var(--gray-a3)", borderRadius: "10px" }}>
                    <Text size="1" style={{ color: "var(--gray-a10)" }}>Player</Text>
                    <Text style={{ fontFamily: "monospace", wordBreak: "break-all" }}>{data.player}</Text>
                  </div>
                  <div style={{ padding: "0.75rem", background: "var(--gray-a3)", borderRadius: "10px" }}>
                    <Text size="1" style={{ color: "var(--gray-a10)" }}>Player move</Text>
                    <Text size="3">{moveName(data.playerMove)}</Text>
                  </div>
                  <div style={{ padding: "0.75rem", background: "var(--gray-a3)", borderRadius: "10px" }}>
                    <Text size="1" style={{ color: "var(--gray-a10)" }}>Machine move</Text>
                    <Text size="3">{moveName(data.machineMove)}</Text>
                  </div>
                </div>
                <div style={{ padding: "0.75rem", background: "var(--gray-a3)", borderRadius: "10px" }}>
                  <Text size="1" style={{ color: "var(--gray-a10)" }}>Match object</Text>
                  <Text style={{ fontFamily: "monospace", wordBreak: "break-all" }}>{objectId}</Text>
                </div>
              </div>
            ) : (
              <Text size="2" style={{ color: "var(--gray-a10)" }}>No match loaded yet.</Text>
            )}
          </div>

          {state.hash && (
            <div style={{ background: "rgba(255,255,255,0.03)", border: "1px solid rgba(255,255,255,0.08)", borderRadius: "16px", padding: "1rem" }}>
              <Text size="2" style={{ display: "block", marginBottom: "0.35rem" }}>Latest transaction</Text>
              <Text style={{ fontFamily: "monospace", wordBreak: "break-all" }}>{state.hash}</Text>
              {state.isConfirmed && (
                <Text size="2" style={{ color: "var(--green-10)", marginTop: "0.35rem", display: "block" }}>
                  Confirmed on-chain
                </Text>
              )}
            </div>
          )}
        </div>
      </Container>
    </div>
  )
}

export default SampleIntegration

```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0x019f66584bfda8c80ebf6ddd685a06e4cec9dd77e20f64c00eb5417bf20635c8` and Module: `game`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
